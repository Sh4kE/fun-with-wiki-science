# Personal knowledge base


## Problem

In the age of information the body of knowledge is in a state of
neverending expansion. It is hard to keep up to date with the newest
developments in large scale but even in a small restricted subset such
as the own academic discipline it is a tremendous work. However, with
the developments in artificial intelligence and data science it
appears to be feasible to ease the workload on the human being by
discovering the semantic structure of the documents the user is
interested in and find similar documents which have relevance to the
already discovered ones. Furthermore with such an approach management
of literature is simplified: All read documents are available,
searchable and ready to export to an output format of the users
choice.

With this project we would like to implement a basic proof of concept
using several techniques to achieve the above.

We started this project in another github project, and we are too lazy to
copy it over into the data-science project. Thus I'm linkting to it here:
https://github.com/Sh4kE/fun-with-wiki-science

## Theoretical Approach

### Semantic analysis

In order to expose the semantic structure of the documents we are
dealing with we chose the LDA. Without going into to many details, it
is sufficient to know that it exposes the semantic structure of the
documents.  On a high level this is a rather simple process. First,
vocabularies are probabilities of certain words over an alphabet of words. Each vocabulary represents a topic and we would like to represent a document as a mixture of topics.
For instance when reading papers about computer science the term
``database`` will occur with a bigger probability than when reading
papers about social sciences. However, note that this may be
ambigious, since sometimes certain term are used with different
connations in different ways e.g. traveling as in the traveling
salesman problem and traveling as part of a voyage.
Given a pdf, we first extract the fulltext of it. Clean it up to
 some point by removing fillwords such as is and then. After the
document is translated into a bag of words(bow) representation.
In order, to assign topics to a document, it is sufficent to randomly
draw words from the bow and take a look at the result.

### User model

So given that we know what a document is about, how we can do
recommandations for the user?  Of course, we could just pick the
articles randomly but this would defy the purpose of the system.
There must be some way to connect the user interest and the topics of
the articles he read.  After considering several different approaches,
we came to the conclusion that the simple way is the best: Represent
the user as a document in the vector space of documents. However, he
is different from the other documents, since he can move in the vector
space meanwhile the other documents are stationary. Since the vector
of the documents is generated from their bag of words, we simply
represent the user as a bag of words. In order to achieve this we have
to implement a simple algebra for addition and substraction of bows.
This directly corresponds to the user liking or disliking articles and
topics.


### Suggesting the new article

The recommandation gets very simple with the above user model. Due to
the fact that documents and the user are vectors in a vector space, we
can just calculate the cosine similarity between the user and all
articles he has not read yet and select the article with the greatest similarity.

### Implementation Details

For implementation we have used a couple of different libraries and
external tools.  Most importantly, we have used the gensim library in
order to obtain a LDA model. This model was generated by gensim with
a dump of wikipedia. After we have consulted the literature, we have
decided that the right amount of topics for our purpose was
400. This may be a bad choice though, since we do not have the
experience to make the right call.  The number of topics provides the
resolution with which we can perceive the articles and assign topics
to them. However, a number to large requires too long to generate the
modell meanwhile a number to small makes us blind when we deal with
specialised terms. Solving this dilemma requires some trial and error
for which we did not have the time for.

For persistence we have used mongodb with the python driver. For
faster calculations, we have used numpy with the Anaconda Accelerate
extension.

The source of our articles was arxiv, since it makes a lot of articles
with fulltext available through an API. Parsing of the API was done by beautiful soup.

### How to use it

#### Creating a project

```python
import project
logic_project = project.Project("Logic")
```

#### Adding sources

```python
import sources
sources.show_subcats() # gives you a list of all available sub-categories
                       # from which you can choose some to add

sources.show_subcats("logic") # It is also possible to filter the result.
# > [('math.LO', 'Logic'), ('cs.LO', 'Logic in Computer Science')]

sources.add_source(('cs.LO', 'Logic in Computer Science'))
```

#### Downloading PDF's

After adding some sources one can then start to fetch the pdf's, which
downloads the pdf's into a subdirectory articles in the root directory.
It also adds entries for all papers into the mongoDB.

```python
import arxiv_import as ai
for x in sources.db.find():
  ai.fetch(x['link'])
```

#### Extracting text
This adds a new field text to the entries in the mongoDB.

```python
import arxiv_preprocessor as ap
ap.update_db_with_pdf_texts()
```

#### Rate Up/Down
After you have read the articles (,which are still inside the articles directory)
you can go ahead and rate them, either up or down. Rating a paper up means, that it
gets added to the users bow, in order to give him better recommendations.

Now let's pretend we've read the book Logic Column 18: Alternative Logics: A Book Review
and it was great ;D

```python
entry = ai.db.find_one({'title':'Logic Column 18: Alternative Logics: A Book Review'})
logic_project.up(entry)
```

#### Recommend

Now we are finally there and we can recommend new undiscovered books.

```python
import recom
recoms = recom.recommend(logic_project)
print recoms[0]['title']
# > Logic Column 16: Higher-Order Abstract Syntax: Setting the Record\n  Straight
```

### Lessons learned

Our initial assumption that this would be complicated and take a long
time to work out was proved wrong. This was a pleasant suprise.

However, the topic decomposition of the articles is quite broad.  We
assume that the reason for this that we have used a common knowledge
corpus and not one with specialised knowledge. This may be remedied by
using an online learning LDA with already given articles as basis for
the corpus. This approach may not be practical though since it
requires the user to have the articles at hand. Therefore a good
initial corpus should be constructed by selecting seminal papers manually.

## Conclusion

All in all the system works better than we have initial expected with
certain details still demanding attention. However, we could make
recommandations which appeared to make sense.
